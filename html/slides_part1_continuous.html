<!DOCTYPE html>
<html lang="ko-KR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI의 진화: 기계는 생각할 수 있는가? - Phase I</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', system-ui, sans-serif;
            line-height: 1.6;
            color: #1d1d1f;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            overflow-x: hidden;
        }
        
        /* Layout */
        .main-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            width: 100%;
            padding-left: 192px; /* 스크롤 스파이 공간 */
        }
        
        .content-wrapper {
            max-width: 1024px;
            width: 100%;
            padding: 32px;
            margin: 0 auto;
            position: relative;
            left: 40px; /* 살짝 오른쪽으로 이동하여 실제 중앙에 배치 */
        }
        
        /* Navigation */
        .nav-container {
            position: fixed;
            top: 33px;
            right: 24px;
            z-index: 40;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .nav-button {
            background: transparent;
            color: #000;
            border: 1px solid #000;
            border-radius: 0.125rem;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            width: auto;
            box-shadow: none;
            opacity: 0.6;
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
            background: rgba(0, 0, 0, 0.05);
            opacity: 1.0;
        }
        
        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, #495057 0%, #6c757d 100%);
            z-index: 50;
            transition: width 0.3s;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.5);
        }
        
        /* Scroll Spy */
        .scroll-spy {
            position: fixed;
            left: 0;
            top: 33px;
            bottom: 33px;
            width: 192px;
            z-index: 40;
            display: flex;
            align-items: center;
            padding: 0 16px;
        }
        
        .scroll-spy-item {
            padding: 2px 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            line-height: 1.3;
            border-left: 2px solid transparent;
            color: #666;
            box-sizing: border-box;
            overflow: hidden;
            font-style: italic;
            opacity: 0.5;
        }
        
        .scroll-spy-item:hover {
            background: #f5f5f5;
            border-left-color: #ddd;
            color: #333;
            opacity: 0.7;
        }
        
        .scroll-spy-item.active {
            background: #f0f0f0;
            border-left-color: #000;
            color: #000;
            font-weight: 500;
            opacity: 1.0;
        }
        
        /* 번호 스타일 제거됨
        .scroll-spy-number {
            display: inline-block;
            width: 24px;
            font-weight: 500;
            color: #999;
            font-size: 10px;
        }
        
        .scroll-spy-item.active .scroll-spy-number {
            color: #000;
        } */
        
        /* Slides */
        .lead-slide {
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 120, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(160, 160, 160, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(200, 200, 200, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #f0f0f2 0%, #e8e8ea 25%, #d8d8da 50%, #c8c8ca 75%, #b8b8ba 100%);
            color: #fff;
            text-align: center;
            padding: 180px 48px;
            margin-bottom: 64px;
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 32px 64px rgba(0, 0, 0, 0.08),
                0 16px 32px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        
        .lead-slide::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 70%),
                radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
            pointer-events: none;
        }
        
        .lead-slide::after {
            content: 'AI의 진화: 기계는 생각할 수 있는가?';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-size: 120px;
            font-weight: 100;
            color: rgba(255, 255, 255, 0.08);
            word-wrap: break-word;
            overflow: hidden;
            line-height: 1.4;
            letter-spacing: 0.1em;
            filter: blur(2px);
            pointer-events: none;
            animation: text-flow 50s linear infinite;
            z-index: 1;
        }
        
        @keyframes text-flow {
            0% { transform: translateY(0%) rotate(0deg); }
            100% { transform: translateY(-30%) rotate(1deg); }
        }
        
        .lead-slide h1, .lead-slide h3, .lead-slide p, .lead-slide strong, .lead-slide code, .lead-slide ul, .lead-slide li {
            color: #fff !important;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }
        
        .lead-slide h1 {
            font-size: 18px !important;
            font-weight: 400 !important;
            color: #000 !important;
            opacity: 0.7;
            letter-spacing: 0.02em;
            margin-bottom: 16px !important;
            text-shadow: none !important;
            position: relative;
            z-index: 10;
        }
        
        /* 가장 강력한 CSS 선택자로 h2 스타일 강제 적용 */
        body .main-container .content-wrapper .lead-slide h2,
        html body .main-container .content-wrapper .lead-slide h2,
        .lead-slide h2,
        .lead-slide h2 *,
        div.lead-slide h2,
        .slide-card.lead-slide h2 {
            font-size: 64px !important;
            font-weight: 900 !important;
            color: #000000 !important;
            opacity: 1.0 !important;
            letter-spacing: -0.02em !important;
            margin: 24px 0 48px 0 !important;
            text-shadow: 0 0 1px rgba(0,0,0,0.8) !important;
            line-height: 1.2 !important;
            background: none !important;
            background-color: transparent !important;
            -webkit-text-fill-color: #000000 !important;
            -webkit-background-clip: unset !important;
            background-clip: unset !important;
            filter: none !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        .lead-slide p {
            font-size: 24px !important;
            font-weight: 300 !important;
            opacity: 0.8;
            letter-spacing: 0.01em;
            line-height: 1.8;
        }
        
        /* strong 태그의 배경색 제거 */
        .lead-slide strong {
            background: none !important;
            padding: 0 !important;
            font-weight: 600 !important;
        }
        
        .slide-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 48px;
            margin-bottom: 32px;
            border-left: 4px solid #6c757d;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .slide-card p, .slide-card strong, .slide-card code, .slide-card ul, .slide-card li {
            color: #424245;
        }
        
        .slide-card:hover {
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
            transform: translateY(-4px);
            transition: all 0.3s ease;
        }
        
        /* Typography */
        h1 {
            font-size: 64px;
            font-weight: 800;
            margin-bottom: 48px;
            line-height: 1.1;
            color: #0064FF;
            opacity: 0.8;
        }
        
        .slide-card h2, .content-wrapper h2:not(.lead-slide h2) {
            font-size: 48px;
            font-weight: 700;
            margin: 24px 0 36px 0;
            color: #0064FF;
            opacity: 0.8;
        }
        
        h3 {
            font-size: 32px;
            font-weight: 600;
            margin: 16px 0 28px 0;
            color: #0064FF;
            opacity: 0.8;
        }
        
        p {
            margin-bottom: 16px;
            color: #424245;
        }
        
        strong {
            font-weight: 700;
            background: #f0f0f0;
            padding: 2px 8px;
        }
        
        code {
            font-family: 'JetBrains Mono', monospace;
            background: #f5f5f5;
            color: #333;
            padding: 2px 6px;
            font-size: 14px;
            border-radius: 3px;
        }
        
        pre {
            background: #1a1a1a;
            color: #f1f1f1;
            padding: 32px;
            overflow-x: auto;
            margin: 24px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            border-left: 4px solid #6c757d;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid #333;
            border-radius: 8px;
        }
        
        pre code {
            background: transparent !important;
            color: #f1f1f1 !important;
            padding: 0;
            font-size: inherit;
        }
        
        /* Pygments 코드 하이라이팅 스타일 */
        pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.hll { background-color: #49483e }
.c { color: #959077 } /* Comment */
.err { color: #ED007E; background-color: #1E0010 } /* Error */
.esc { color: #F8F8F2 } /* Escape */
.g { color: #F8F8F2 } /* Generic */
.k { color: #66D9EF } /* Keyword */
.l { color: #AE81FF } /* Literal */
.n { color: #F8F8F2 } /* Name */
.o { color: #FF4689 } /* Operator */
.x { color: #F8F8F2 } /* Other */
.p { color: #F8F8F2 } /* Punctuation */
.ch { color: #959077 } /* Comment.Hashbang */
.cm { color: #959077 } /* Comment.Multiline */
.cp { color: #959077 } /* Comment.Preproc */
.cpf { color: #959077 } /* Comment.PreprocFile */
.c1 { color: #959077 } /* Comment.Single */
.cs { color: #959077 } /* Comment.Special */
.gd { color: #FF4689 } /* Generic.Deleted */
.ge { color: #F8F8F2; font-style: italic } /* Generic.Emph */
.ges { color: #F8F8F2; font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.gr { color: #F8F8F2 } /* Generic.Error */
.gh { color: #F8F8F2 } /* Generic.Heading */
.gi { color: #A6E22E } /* Generic.Inserted */
.go { color: #66D9EF } /* Generic.Output */
.gp { color: #FF4689; font-weight: bold } /* Generic.Prompt */
.gs { color: #F8F8F2; font-weight: bold } /* Generic.Strong */
.gu { color: #959077 } /* Generic.Subheading */
.gt { color: #F8F8F2 } /* Generic.Traceback */
.kc { color: #66D9EF } /* Keyword.Constant */
.kd { color: #66D9EF } /* Keyword.Declaration */
.kn { color: #FF4689 } /* Keyword.Namespace */
.kp { color: #66D9EF } /* Keyword.Pseudo */
.kr { color: #66D9EF } /* Keyword.Reserved */
.kt { color: #66D9EF } /* Keyword.Type */
.ld { color: #E6DB74 } /* Literal.Date */
.m { color: #AE81FF } /* Literal.Number */
.s { color: #E6DB74 } /* Literal.String */
.na { color: #A6E22E } /* Name.Attribute */
.nb { color: #F8F8F2 } /* Name.Builtin */
.nc { color: #A6E22E } /* Name.Class */
.no { color: #66D9EF } /* Name.Constant */
.nd { color: #A6E22E } /* Name.Decorator */
.ni { color: #F8F8F2 } /* Name.Entity */
.ne { color: #A6E22E } /* Name.Exception */
.nf { color: #A6E22E } /* Name.Function */
.nl { color: #F8F8F2 } /* Name.Label */
.nn { color: #F8F8F2 } /* Name.Namespace */
.nx { color: #A6E22E } /* Name.Other */
.py { color: #F8F8F2 } /* Name.Property */
.nt { color: #FF4689 } /* Name.Tag */
.nv { color: #F8F8F2 } /* Name.Variable */
.ow { color: #FF4689 } /* Operator.Word */
.pm { color: #F8F8F2 } /* Punctuation.Marker */
.w { color: #F8F8F2 } /* Text.Whitespace */
.mb { color: #AE81FF } /* Literal.Number.Bin */
.mf { color: #AE81FF } /* Literal.Number.Float */
.mh { color: #AE81FF } /* Literal.Number.Hex */
.mi { color: #AE81FF } /* Literal.Number.Integer */
.mo { color: #AE81FF } /* Literal.Number.Oct */
.sa { color: #E6DB74 } /* Literal.String.Affix */
.sb { color: #E6DB74 } /* Literal.String.Backtick */
.sc { color: #E6DB74 } /* Literal.String.Char */
.dl { color: #E6DB74 } /* Literal.String.Delimiter */
.sd { color: #E6DB74 } /* Literal.String.Doc */
.s2 { color: #E6DB74 } /* Literal.String.Double */
.se { color: #AE81FF } /* Literal.String.Escape */
.sh { color: #E6DB74 } /* Literal.String.Heredoc */
.si { color: #E6DB74 } /* Literal.String.Interpol */
.sx { color: #E6DB74 } /* Literal.String.Other */
.sr { color: #E6DB74 } /* Literal.String.Regex */
.s1 { color: #E6DB74 } /* Literal.String.Single */
.ss { color: #E6DB74 } /* Literal.String.Symbol */
.bp { color: #F8F8F2 } /* Name.Builtin.Pseudo */
.fm { color: #A6E22E } /* Name.Function.Magic */
.vc { color: #F8F8F2 } /* Name.Variable.Class */
.vg { color: #F8F8F2 } /* Name.Variable.Global */
.vi { color: #F8F8F2 } /* Name.Variable.Instance */
.vm { color: #F8F8F2 } /* Name.Variable.Magic */
.il { color: #AE81FF } /* Literal.Number.Integer.Long */
        /* 코드 블록 래퍼 스타일 */
        .code-block-wrapper {
            position: relative;
            margin: 24px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .code-block-wrapper .highlight {
            margin: 0 !important;
            border-radius: 0 !important;
        }
        
        .code-block-wrapper pre {
            margin: 0 !important;
            padding: 24px !important;
            border-radius: 0 !important;
            border: none !important;
            box-shadow: none !important;
        }
        
        /* 언어 라벨 */
        .code-language {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            backdrop-filter: blur(10px);
            z-index: 10;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* 코드 하이라이팅 개선 */
        .highlight {
            line-height: 1.6 !important;
            font-family: 'JetBrains Mono', monospace !important;
            font-size: 14px !important;
        }
        
        /* 다크 테마에서 코드 블록 스타일 */
        .lead-slide .code-block-wrapper {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .lead-slide .code-language {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* 비디오 컨테이너 */
        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 비율 */
            margin: 24px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* 이미지 컨테이너 */
        .image-container {
            margin: 24px auto;
            text-align: center;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            background: #fff;
            width: 50%;
            max-width: 512px;
        }
        
        .image-container img {
            width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            transition: transform 0.3s ease;
        }
        
        .image-container:hover img {
            transform: scale(1.02);
        }
        
        /* 큰 이미지 컨테이너 (:=big 옵션) */
        .image-container-big {
            margin: 24px auto;
            text-align: center;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            background: #fff;
            width: 100%;
            max-width: 800px;
        }
        
        .image-container-big img {
            width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            transition: transform 0.3s ease;
        }
        
        .image-container-big:hover img {
            transform: scale(1.02);
        }
        
        /* 링크 스타일 */
        a {
            color: #0064FF;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.2s;
        }
        
        a:hover {
            border-bottom-color: #0064FF;
        }
        
        .lead-slide a {
            color: #0064FF;
        }
        
        .lead-slide a:hover {
            border-bottom-color: #0064FF;
            transform: translateY(2px);
        }
    
        
        ul, ol {
            margin: 24px 0;
            padding-left: 24px;
        }
        
        li {
            margin-bottom: 8px;
            color: #424245;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
            background: white;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid #e5e5e5;
        }
        
        th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
        }
        
        tr:hover {
            background: #f9f9f9;
        }
        
        /* Utilities */
        .page-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #e5e5e5;
        }
        
        .page-number {
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }
        
        .page-label {
            font-size: 12px;
            color: #999;
            background: #f5f5f5;
            padding: 4px 12px;
        }
        
        .divider {
            height: 1px;
            background: #e5e5e5;
            margin: 48px auto;
            max-width: 600px;
        }
        
        .footer {
            background: #f5f5f5;
            padding: 32px;
            margin-top: 64px;
            text-align: center;
            border-top: 1px solid #e5e5e5;
        }
        
        .footer-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .footer-subtitle {
            font-size: 14px;
            color: #666;
        }
        
        /* Hide on small screens */
        @media (max-width: 1024px) {
            .scroll-spy {
                display: none;
            }
            
            .main-container {
                padding-left: 0; /* 모바일에서는 왼쪽 패딩 제거 */
            }
            
            .content-wrapper {
                left: 0; /* 모바일에서는 중앙 보정 제거 */
            }
            
            .nav-container {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>
    
    <!-- Navigation -->
    <div class="nav-container">
        <button onclick="scrollToTop()" class="nav-button">↑ Top</button>
        <button onclick="scrollToBottom()" class="nav-button">↓ End</button>
    </div>
    
    <!-- Scroll Spy -->
    <div class="scroll-spy" id="scrollSpy">
        <div id="scrollSpyList">
            <!-- Scroll spy items will be generated dynamically -->
        </div>
    </div>

    <div class="main-container">
        <div class="content-wrapper">

        <!-- Lead Slide 1 -->
        <div class="lead-slide" id="slide-1">
            <h1>위데이터랩 인공지능 트렌드 강연</h1>
            <h2>Phase I: AI의 기원과 진화</h2>
            <p style="margin-top: 32px; opacity: 0.8;"><a href="#slide-2" style="color: inherit; text-decoration: none;">스크롤하여 계속 읽기 ↓</a></p>
        </div>
        
        <div class="divider"></div>

        <!-- Slide 2 -->
        <div class="slide-card" id="slide-2">
            <h3 id="1-강연-개요와-핵심-질문">1. 강연 개요와 핵심 질문</h3>

<p><strong>"기계는 생각할 수 있는가?" - AI의 출발점이 된 철학적 물음</strong></p>

<p>위데이터랩 인공지능 트렌드 강연에 오신 것을 환영합니다. </p>

<p>오늘 우리는 1950년 앨런 튜링이 던진 이 질문에서 시작하여, 현재 Agentic AI까지의 여정을 탐험합니다. 이 질문은 단순한 철학적 사유를 넘어 인공지능 연구의 근본적 동기가 되었으며, 70년이 지난 지금도 여전히 우리에게 중요한 의미를 던지고 있습니다.</p>

<p>위데이터랩은 DB 모니터링에서 시작하여 RAG/Agent 관찰성, YOLO 결함 탐지, 온프레미스 AI 플랫폼까지 다양한 AI 프로젝트를 수행하며 데이터와 AI로 고객의 가치를 창출하는 기업입니다.</p>

<p></p>

<div class="image-container">
    <img src="https://manhattanrarebooks.cdn.bibliopolis.com/pictures/227.jpg?auto=webp&v=1354507081" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">2 / 28</div>
                <div class="page-label">Slide 2</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 3 -->
        <div class="slide-card" id="slide-3">
            <h3 id="2-튜링의-유산-지능의-정의와-튜링-테스트">2. 튜링의 유산: 지능의 정의와 튜링 테스트</h3>

<p><strong>기계 지능 판별의 첫 번째 이정표</strong></p>

<p>앨런 튜링은 "기계가 생각할 수 있는가?"라는 추상적 질문을 "기계가 인간처럼 대화할 수 있는가?"라는 실험 가능한 형태로 전환했습니다. </p>

<p>튜링 테스트는 다음과 같이 작동합니다:<br />
- 심사자가 보이지 않는 상대와 텍스트로 대화<br />
- 상대가 인간인지 기계인지 구별할 수 없다면 기계가 '사고'한다고 볼 수 있음<br />
- 이는 AI 목표 설정의 첫 번째 구체적인 이정표가 됨</p>

<p>이 테스트는 완벽하지 않지만, 인공지능이 추구해야 할 방향을 제시했습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://flexible.img.hani.co.kr/flexible/normal/661/504/imgdb/original/2025/0407/20250407500536.jpg" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">3 / 28</div>
                <div class="page-label">Slide 3</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 4 -->
        <div class="slide-card" id="slide-4">
            <h3 id="3-사이버네틱스-ai의-숨겨진-뿌리-1948">3. 사이버네틱스: AI의 숨겨진 뿌리 (1948)</h3>

<p><strong>노버트 위너와 제어 시스템의 과학</strong></p>

<p>1948년 MIT의 노버트 위너가 출간한 "Cybernetics: Or Control and Communication in the Animal and the Machine"은 AI의 중요한 지적 토대가 되었습니다.</p>

<p><strong>사이버네틱스의 핵심 개념:</strong><br />
위너는 생물체와 기계가 모두 정보를 처리하고 피드백을 통해 행동을 조절하는 시스템이라고 보았습니다. 생물학의 항상성(homeostasis) 개념에서 영감을 받아, 시스템이 외부 변화에도 내부 균형을 유지하는 메커니즘을 수학적으로 모델링했습니다. </p>

<p>체온 조절, 혈당 조절 같은 생물학적 항상성과 마찬가지로, 자동 온도 조절기도 목표 온도를 유지하기 위해 지속적으로 피드백을 받아 조정합니다. 이러한 네거티브 피드백 루프가 적응적 행동의 기초이며, 지능의 본질이라고 주장했습니다.</p>

<p><strong>AI에 미친 영향:</strong><br />
사이버네틱스는 학습을 "시스템이 피드백을 통해 행동을 개선하는 과정"으로 정의했고, 이는 현재 강화학습의 기초가 되었습니다. 또한 인간-기계 상호작용, 적응 시스템, 자기 조직화 같은 개념들이 후에 AI 연구의 중요한 주제가 되었습니다.</p>

<p>위너의 동료였던 클로드 섀넌(정보이론), 워런 맥컬록(인공 뉴런)도 사이버네틱스 운동에 참여했으며, 이들의 아이디어는 다트머스 회의로 이어졌습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://upload.wikimedia.org/wikipedia/commons/3/33/Cybernetics.jpg" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">4 / 28</div>
                <div class="page-label">Slide 4</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 5 -->
        <div class="slide-card" id="slide-5">
            <h3 id="4-ai의-공식-탄생-다트머스-회의-1956">4. AI의 공식 탄생: 다트머스 회의 (1956)</h3>

<p><strong>'Artificial Intelligence' 용어의 탄생과 야심찬 시작</strong></p>

<p>1956년 여름, 다트머스 대학에서 열린 2개월간의 워크숍이 AI를 정식 학문 분야로 탄생시켰습니다.</p>

<p><strong>주요 참석자와 그들이 AI에 미친 영향:</strong><br />
존 매카시는 'Artificial Intelligence'라는 용어를 만들고 1958년 LISP를 개발했습니다. LISP는 이후 30년간 AI 연구의 주언어가 되었고, 현재도 Clojure 등으로 명맥을 이어가고 있습니다.</p>

<p>마빈 민스키는 1951년 SNARC로 최초의 신경망을 시뮬레이션했고, 1959년 MIT AI Lab을 공동 설립했습니다. 그의 연구실에서 컴퓨터 비전, 로봇공학, 자연어처리의 기초가 만들어졌습니다.</p>

<p>클로드 섀넌은 1948년 정보이론으로 디지털 통신의 수학적 기초를 제공했고, 1950년 체스 프로그램 논문으로 게임 AI의 시초를 열었습니다. </p>

<p>허버트 사이먼과 앨런 뉴웰은 1956년 Logic Theorist로 Principia Mathematica의 정리 52개 중 38개를 자동 증명했습니다. 이는 기계가 창의적 사고를 할 수 있다는 최초의 실증이었습니다.</p>

<p><strong>초기 목표:</strong><br />
"모든 학습의 측면이나 지능의 다른 특징들을 정확히 기술할 수 있어서, 기계가 이를 시뮬레이션할 수 있도록 만들 수 있다"</p>

<p>이들은 인간 사고의 원리를 수학과 논리로 완전히 모델링할 수 있다고 믿었습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://spectrum.ieee.org/media-library/historical-photo-of-seven-smiling-men-sitting-on-a-lawn-in-front-of-a-tree-and-a-white-school-building-with-many-windows.jpg?id=33603743&width=1200&height=600&coordinates=0%2C0%2C0%2C30" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">5 / 28</div>
                <div class="page-label">Slide 5</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 6 -->
        <div class="slide-card" id="slide-6">
            <h3 id="6-생물학적-영감-맥컬록-피츠의-인공-뉴런-1943">6. 생물학적 영감: 맥컬록-피츠의 인공 뉴런 (1943)</h3>

<p><strong>뇌에서 영감을 받은 최초의 수학적 모델</strong></p>

<p>1943년, 신경생리학자 워런 맥컬록과 수학자 월터 피츠는 뇌의 뉴런을 수학적으로 모델링했습니다.</p>

<p><strong>핵심 아이디어:</strong><br />
- 뉴런은 입력의 가중합이 임계값을 넘으면 활성화<br />
- 논리 게이트처럼 AND, OR, NOT 연산 구현 가능<br />
- 단순한 단위들의 연결로 복잡한 계산 가능</p>

<p>이 모델은 단순했지만, 생물학적 시스템을 인공적으로 구현할 수 있다는 가능성을 보여준 획기적인 시도였습니다. 현대 딥러닝의 기초가 되는 개념입니다.</p>

<p>
<div class="image-container-big">
    <img src="https://cdn.prod.website-files.com/60ab0571dc2b4b3a7165c912/67077d28fe3b63556b9ba734_6183c8f6580ea54efd7391e5_a%2520logical%2520calculus.jpeg" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">6 / 28</div>
                <div class="page-label">Slide 6</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 7 -->
        <div class="slide-card" id="slide-7">
            <h3 id="7-학습하는-기계의-탄생-로젠블랫의-퍼셉트론-1957">7. 학습하는 기계의 탄생: 로젠블랫의 퍼셉트론 (1957)</h3>

<p><strong>최초의 학습 알고리즘과 패턴 인식</strong></p>

<p>프랭크 로젠블랫의 퍼셉트론은 "기계가 경험을 통해 학습할 수 있다"는 혁명적 개념을 구현했습니다.</p>

<p><strong>퍼셉트론의 특징:</strong><br />
- 입력에 가중치를 곱하고 합산하여 출력 결정<br />
- 오류에 따라 가중치를 자동으로 조정<br />
- 선형 분리 가능한 패턴 학습 가능</p>

<p><strong>초기 성공 사례:</strong><br />
- 손글씨 숫자 인식<br />
- 간단한 도형 분류<br />
- 기본적인 패턴 인식 작업</p>

<p>
<div class="image-container-big">
    <img src="https://data-science-blog.com/wp-content/uploads/2020/07/perceptron_1-1030x501.png" alt="이미지" loading="lazy" />
</div> 하지만 XOR 문제 같은 비선형 문제를 해결할 수 없다는 한계가 곧 드러났습니다.</p>

            
            <div class="page-info">
                <div class="page-number">7 / 28</div>
                <div class="page-label">Slide 7</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 8 -->
        <div class="slide-card" id="slide-8">
            <h3 id="8-두-가지-접근법-상징주의-vs-연결주의">8. 두 가지 접근법: 상징주의 vs 연결주의</h3>

<p><strong>AI 발전의 첫 번째 갈림길</strong></p>

<p>초기 AI 연구는 두 가지 근본적으로 다른 접근법으로 나뉘었습니다:</p>

<p><strong>상징주의 (Symbolic AI)의 철학과 구현:</strong><br />
상징주의는 인간의 사고를 논리 기호의 조작으로 설명할 수 있다는 믿음에서 출발했습니다. 1960년대 Newell과 Simon의 General Problem Solver는 수단-목적 분석(means-ends analysis)으로 문제를 해결했고, 이는 현재 AI 계획(planning) 알고리즘의 기초가 되었습니다. </p>

<p>대표적 성공 사례는 1970-80년대 전문가 시스템입니다. MYCIN은 혈액 감염 진단에서 전문의 수준의 정확도를 보였고, DENDRAL은 질량 분석 데이터로 분자 구조를 추론했습니다. 그러나 지식 획득의 병목(knowledge acquisition bottleneck)과 조합 폭발 문제로 한계에 봉착했습니다.</p>

<p><strong>연결주의 (Connectionist AI)의 생물학적 영감:</strong><br />
연결주의는 뇌의 1000억 개 뉴런이 시냅스로 연결된 구조에서 지능이 창발한다고 봅니다. 1986년 역전파 알고리즘의 재발견으로 다층 신경망 학습이 가능해졌고, 1989년 LeCun의 LeNet은 우편번호 인식에서 99% 정확도를 달성했습니다.</p>

<p>핵심은 명시적 규칙 없이도 데이터에서 패턴을 학습한다는 점입니다. XOR 문제 해결, 음성 인식, 이미지 분류 등에서 성공을 거두며 현재 딥러닝의 토대가 되었습니다.</p>

<p>이 두 접근법의 경쟁과 융합이 AI 발전의 원동력이 되었습니다.</p>

            
            <div class="page-info">
                <div class="page-number">8 / 28</div>
                <div class="page-label">Slide 8</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 9 -->
        <div class="slide-card" id="slide-9">
            <h3 id="9-뉴로심볼릭-ai-특정-문제를-위한-보완적-접근-2020년대">9. 뉴로심볼릭 AI: 특정 문제를 위한 보완적 접근 (2020년대)</h3>

<p><strong>신경망의 한계를 극복하기 위한 하이브리드 시도</strong></p>

<p>2020년대 들어 뉴로심볼릭 AI가 특정 영역에서 실험되고 있습니다. 이는 주류 기술이라기보다는 신경망이 어려워하는 특정 문제들을 해결하기 위한 보완적 접근입니다.</p>

<p><strong>뉴로심볼릭 접근법의 특징:</strong><br />
딥러닝이 패턴 인식과 특징 추출을 담당하고, 심볼릭 시스템이 논리적 추론과 설명 가능성을 제공합니다. 예를 들어, DeepMind의 AlphaGeometry는 신경망으로 기하학적 패턴을 학습하고 심볼릭 추론기로 정리를 증명하여, 국제수학올림피아드 기하 문제의 30문제 중 25문제를 해결했습니다.</p>

<p><strong>실제 구현 사례:</strong><br />
IBM의 Neuro-Symbolic Concept Learner는 이미지 캡셔닝에서 98.9% 정확도를 달성하면서도 "왜 이 물체가 고양이인가?"같은 질문에 논리적으로 답할 수 있습니다. MIT의 연구진은 프로그램 합성(program synthesis)을 통해 신경망이 학습한 것을 실행 가능한 코드로 변환하는 기술을 개발했습니다.</p>

<p><strong>Lean과 형식 증명의 혁명:</strong><br />
2024년 Google DeepMind의 AlphaProof는 Lean 정리 증명 보조기를 사용해 국제수학올림피아드 은메달 수준의 문제를 해결했습니다. Lean 4의 210,000개 이상의 형식화된 정리와 100,000개의 정의는 AI가 수학적 추론을 학습하는 데이터베이스가 되었습니다. 특히 DeepSeek-Prover는 miniF2F 벤치마크에서 46.3% 정확도로 GPT-4의 23%를 크게 앞섰습니다.</p>

<p><strong>Knowledge Graph와 추론의 결합:</strong><br />
Knowledge Graph는 뉴로심볼릭 AI의 핵심 인프라로 부상했습니다. Google의 지식 그래프는 5000억 개 이상의 팩트를 포함하고 있으며, 이를 신경망과 결합해 복잡한 다단계 추론이 가능해졌습니다. AllegroGraph같은 플랫폼은 RDF, 벡터, JSON을 통합 관리하며 SPARQL 쿼리와 LLM을 연결합니다. 의료 분야에서는 질병 경로 분석과 신약 개발에서 뛰어난 성과를 보이고 있습니다.</p>

<p><strong>실용적 적용과 한계:</strong><br />
뉴로심볼릭 접근은 주로 수학 증명, 프로그램 합성, 형식 검증 같은 논리적 추론이 필수인 영역에서 유용합니다. 하지만 대부분의 AI 응용에서는 순수 신경망 접근이 더 효과적이고 실용적입니다.</p>

<p>현재 대부분의 상업적 AI 시스템(GPT, Claude, Gemini)은 여전히 순수 신경망 기반입니다. 뉴로심볼릭 기법은 특정 도메인에서 성능을 개선하는 도구로 활용되지만, AI 발전의 주류는 아닙니다. 오히려 대규모 신경망의 창발적 능력이 많은 추론 문제를 해결하고 있습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://allegrograph.com/wp-content/uploads/2024/01/AG-NSAI-Graphic.png" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">9 / 28</div>
                <div class="page-label">Slide 9</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 10 -->
        <div class="slide-card" id="slide-10">
            <h3 id="10-기계와의-첫-대화-eliza-1966">10. 기계와의 첫 대화: ELIZA (1966)</h3>

<p><strong>자연어처리의 시작과 사회적 충격</strong></p>

<p>조셉 바이젠바움이 개발한 ELIZA는 최초로 인간과 자연스러운 대화를 나누는 것처럼 보이는 프로그램이었습니다.</p>

<p><strong>ELIZA의 작동 방식:</strong><br />
- 단순한 패턴 매칭과 규칙 기반 응답<br />
- 심리치료사 역할을 하는 DOCTOR 스크립트<br />
- 사용자의 말을 재구성하여 질문으로 되돌림</p>

<p><strong>예시 대화:</strong><br />
<div class="code-block-wrapper"><div class="highlight" style="background: #272822"><pre style="line-height: 125%;"><span></span>사용자: &quot;저는 우울해요&quot;
ELIZA: &quot;왜 우울하다고 생각하시나요?&quot;
사용자: &quot;아무도 저를 이해하지 못해요&quot;
ELIZA: &quot;아무도 당신을 이해하지 못한다는 것에 대해 더 말씀해 주세요&quot;
</pre></div>
</div></p>

<p>놀랍게도 많은 사용자들이 ELIZA와 감정적 유대감을 느꼈습니다. 이는 인간이 기계에게도 의인화된 속성을 부여한다는 중요한 통찰을 제공했습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://upload.wikimedia.org/wikipedia/commons/7/79/ELIZA_conversation.png" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">10 / 28</div>
                <div class="page-label">Slide 10</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 11 -->
        <div class="slide-card" id="slide-11">
            <h3 id="11-전문가-시스템의-황금기-1970-80년대">11. 전문가 시스템의 황금기 (1970-80년대)</h3>

<p><strong>상업적 성공과 확장성의 한계</strong></p>

<p>전문가 시스템은 인간 전문가의 지식을 규칙 형태로 저장하여 문제를 해결하는 AI의 첫 상업적 성공 사례였습니다.</p>

<p><strong>주요 시스템들:</strong><br />
- MYCIN: 혈액 감염 진단 (정확도 69%, 전문의 평균 65%)<br />
- DENDRAL: 화학 구조 분석<br />
- XCON: 컴퓨터 시스템 구성 (DEC사 연간 4천만 달러 절감)</p>

<p><strong>한계점:</strong><br />
- 지식 획득의 병목 현상 (Knowledge Acquisition Bottleneck)<br />
- 규칙이 늘어날수록 복잡도 폭증<br />
- 새로운 상황에 대한 적응력 부족<br />
- 유지보수의 어려움</p>

<p>전문가 시스템은 특정 영역에서는 성공했지만, 범용 지능으로의 확장은 실패했습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20200319005713/1212121.png" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">11 / 28</div>
                <div class="page-label">Slide 11</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 12 -->
        <div class="slide-card" id="slide-12">
            <h3 id="12-첫-번째-ai-겨울-1974-1980-구체적인-숫자로-본-연구-중단">12. 첫 번째 AI 겨울 (1974-1980): 구체적인 숫자로 본 연구 중단</h3>

<p><strong>DARPA 자금 삭감과 Perceptrons의 영향</strong></p>

<p>1969년 Mansfield Amendment 통과로 DARPA는 "기초 연구"가 아닌 "임무 지향적 연구"만 지원하게 되었습니다. 1974년 Carnegie Mellon의 음성 인식 프로젝트가 실패하자 DARPA는 연간 300만 달러 계약을 취소했습니다.</p>

<p><strong>XOR 문제</strong></p>

<p></p>

<div class="image-container">
    <img src="https://b2633864.smushcdn.com/2633864/wp-content/uploads/2021/04/bitwise_datasets-1024x365.png?lossy=2&strip=1&webp=1" alt="이미지" loading="lazy" />
</div>

<p>단층 퍼셉트론은 선형 분리 가능한 문제만 해결 가능했습니다. XOR은 비선형 문제로, 최소 2층 이상의 네트워크가 필요했으나 당시에는 다층 네트워크 학습법이 없었습니다.</p>

<p><strong>구체적 영향:</strong><br />
- 1973년 영국 Lighthill Report: AI 연구 "과대 약속, 과소 성과" 비판<br />
- MIT AI Lab 예산: 1970년 300만 달러 → 1975년 100만 달러 (67% 감소)<br />
- 신경망 연구 논문: 1970년대 연평균 5편 미만으로 급감</p>

<p></p>

<div class="image-container">
    <img src="https://miro.medium.com/v2/resize:fit:1400/1*mWYZanOv3QUafz0nnhbEWw.png" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">12 / 28</div>
                <div class="page-label">Slide 12</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 13 -->
        <div class="slide-card" id="slide-13">
            <h3 id="13-역전파-알고리즘의-재발견-1986">13. 역전파 알고리즘의 재발견 (1986)</h3>

<p><strong>다층 신경망 학습의 돌파구</strong></p>

<p>1986년, 제프리 힌튼, 데이비드 럼멜하트, 로널드 윌리엄스가 역전파(Backpropagation) 알고리즘을 재발견하고 대중화했습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://devforum-uploads.s3.dualstack.us-east-2.amazonaws.com/uploads/original/4X/1/9/6/196c9cd7e9356e3a72293598ab775d8637412e2a.png" alt="이미지" loading="lazy" />
</div> <strong>역전파의 핵심:</strong><br />
- 출력층의 오류를 입력층까지 역으로 전파<br />
- 각 층의 가중치를 체계적으로 조정<br />
- 다층 신경망의 효율적 학습 가능</p>

<p><strong>XOR 문제 해결:</strong><br />
- 은닉층을 추가한 2층 신경망으로 XOR 학습 성공<br />
- 비선형 활성화 함수 사용<br />
- 복잡한 패턴 학습의 가능성 입증</p>

<p>이로써 신경망 연구가 다시 활발해지며 AI의 두 번째 물결이 시작되었습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://miro.medium.com/v2/1*f9a162GhpMbiTVTAua_lLQ.png" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">13 / 28</div>
                <div class="page-label">Slide 13</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 14 -->
        <div class="slide-card" id="slide-14">
            <h3 id="14-생물학적-영감-네오코그니트론-1980">14. 생물학적 영감: 네오코그니트론 (1980)</h3>

<p><strong>시각 피질을 모방한 계층적 특징 추출</strong></p>

<p>쿠니히코 후쿠시마의 네오코그니트론은 고양이 시각 피질 연구에서 영감을 받아 개발되었습니다.</p>

<p><strong>혁신적 개념:</strong><br />
- S-cells: 특징 검출 (엣지, 코너 등)<br />
- C-cells: 위치 불변성 구현<br />
- 계층적 특징 추출 구조<br />
- 변형에 강건한 패턴 인식</p>

<p>네오코그니트론은 현대 CNN의 개념적 토대가 되었으며, 생물학적 시스템이 AI 발전에 중요한 영감을 제공한다는 것을 보여줬습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://miro.medium.com/v2/resize:fit:1400/0*qq8NM5pgElCjVJBK.png" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">14 / 28</div>
                <div class="page-label">Slide 14</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 15 -->
        <div class="slide-card" id="slide-15">
            <h3 id="15-신경망-아키텍처의-다양화">15. 신경망 아키텍처의 다양화</h3>

<p><strong>문제에 최적화된 구조의 탄생</strong></p>

<p>역전파 알고리즘 이후, 다양한 신경망 구조가 개발되어 특정 문제를 효과적으로 해결했습니다.</p>

<p><strong>주요 아키텍처들:</strong></p>

<p><strong>RNN (Recurrent Neural Network, 1986):</strong><br />
- 시계열 데이터와 순차적 정보 처리<br />
- 이전 상태를 기억하는 피드백 연결<br />
- 음성 인식, 언어 모델링에 활용</p>

<p>
<div class="image-container-big">
    <img src="https://karpathy.github.io/assets/rnn/diags.jpeg" alt="이미지" loading="lazy" />
</div> <strong>LSTM (Long Short-Term Memory, 1997):</strong><br />
- RNN의 장기 의존성 문제 해결<br />
- 게이트 메커니즘으로 정보 선택적 기억<br />
- 기계 번역, 음성 인식의 핵심 기술</p>

<p>
<div class="image-container-big">
    <img src="https://velog.velcdn.com/images/hwkims/post/20cb8966-ec15-4970-9916-128176a44180/image.png" alt="이미지" loading="lazy" />
</div> <strong>CNN (Convolutional Neural Network, late 80's):</strong><br />
- 이미지의 공간적 특징 추출<br />
- 컨볼루션과 풀링 연산<br />
- LeNet-5로 손글씨 인식 실용화 (1989)</p>

<p>
<div class="image-container-big">
    <img src="https://miro.medium.com/v2/resize:fit:3744/1*SGPGG7oeSvVlV5sOSQ2iZw.png" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">15 / 28</div>
                <div class="page-label">Slide 15</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 16 -->
        <div class="slide-card" id="slide-16">
            <h3 id="16-비지도-학습의-돌파구-rbm과-딥-빌리프-네트워크">16. 비지도 학습의 돌파구: RBM과 딥 빌리프 네트워크</h3>

<p><strong>레이블 없는 데이터에서 특징 학습</strong></p>

<p>2006년, 제프리 힌튼은 제한된 볼츠만 머신(RBM)을 이용한 딥 빌리프 네트워크로 딥러닝의 가능성을 보여줬습니다.</p>

<p><strong>RBM의 특징:</strong><br />
- 확률적 생성 모델<br />
- 비지도 학습으로 특징 추출<br />
- 층별 사전학습(Layer-wise Pre-training)</p>

<p><strong>딥러닝 사전학습의 의미:</strong><br />
- 깊은 신경망의 효과적 초기화<br />
- 레이블이 없는 대량 데이터 활용<br />
- Vanishing Gradient 문제 완화</p>

<p>이는 빅데이터 시대에 레이블 없는 데이터를 활용할 수 있는 길을 열었습니다.</p>

            
            <div class="page-info">
                <div class="page-number">16 / 28</div>
                <div class="page-label">Slide 16</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 17 -->
        <div class="slide-card" id="slide-17">
            <h3 id="17-기계학습의-실용화-svm과-앙상블-방법">17. 기계학습의 실용화: SVM과 앙상블 방법</h3>

<p><strong>이론과 실무의 균형</strong></p>

<p>1990년대, 서포트 벡터 머신(SVM)과 앙상블 학습이 실제 문제 해결에서 뛰어난 성능을 보였습니다.</p>

<p><strong>SVM의 강점:</strong><br />
- 수학적으로 명확한 최적화 목표<br />
- 커널 트릭으로 비선형 문제 해결<br />
- 과적합에 강건한 성능</p>

<p>
<div class="image-container-big">
    <img src="https://bradleyboehmke.github.io/HOML/11b-svm_files/figure-html/svm-circle-1.png" alt="이미지" loading="lazy" />
</div> <strong>앙상블 방법:</strong><br />
- Random Forest: 다수의 결정 트리 조합<br />
- AdaBoost: 약한 학습기를 순차적으로 강화<br />
- Gradient Boosting: 잔차 학습으로 성능 개선</p>

<p>
<div class="image-container-big">
    <img src="https://blog.kakaocdn.net/dna/b9en8U/btrKi8l2FXy/AAAAAAAAAAAAAAAAAAAAAAMSrsjuE7zP8yowYMdbTLYqooYOP1USh87xLvkRWp65/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=S9tJ7vs4X7gYB3Fw8MT0xvOcKOY%3D" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">17 / 28</div>
                <div class="page-label">Slide 17</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 18 -->
        <div class="slide-card" id="slide-18">
            <h3 id="18-데이터-시각화와-차원-축소">18. 데이터 시각화와 차원 축소</h3>

<p><strong>고차원 데이터의 직관적 이해</strong></p>

<p>복잡한 고차원 데이터를 이해하기 위한 시각화 기술이 발전했습니다.</p>

<p><strong>주요 기법들:</strong><br />
- PCA (주성분 분석): 선형 차원 축소<br />
- t-SNE: 비선형 매니폴드 학습<br />
- UMAP: 전역 구조 보존 시각화</p>

<p>
<div class="image-container-big">
    <img src="https://moonlight-paper-snapshot.s3.ap-northeast-2.amazonaws.com/arxiv/federated-t-sne-and-umap-for-distributed-data-visualization-4.png" alt="이미지" loading="lazy" />
</div> <strong>활용 사례:</strong><br />
- 단어 임베딩 공간 시각화<br />
- 이미지 특징 공간 탐색<br />
- 클러스터링 결과 검증</p>

<p>이러한 도구들은 AI 모델의 내부 작동을 이해하고 디버깅하는 데 필수적이 되었습니다.</p>

            
            <div class="page-info">
                <div class="page-number">18 / 28</div>
                <div class="page-label">Slide 18</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 19 -->
        <div class="slide-card" id="slide-19">
            <h3 id="19-디지털-혁명과-데이터의-폭발적-증가">19. 디지털 혁명과 데이터의 폭발적 증가</h3>

<p><strong>AI 발전의 연료가 된 빅데이터</strong></p>

<p>2000년대 들어 인터넷과 모바일 기기의 보급으로 데이터가 기하급수적으로 증가했습니다.</p>

<p><strong>데이터 증가의 주요 원인:</strong><br />
- 소셜 미디어: 일일 수십억 개의 게시물<br />
- 스마트폰: 센서 데이터와 사용자 행동 기록<br />
- IoT 기기: 실시간 환경 데이터 수집<br />
- 디지털 상거래: 구매 패턴과 선호도 데이터</p>

<p><strong>데이터의 새로운 특성:</strong><br />
- Volume: 페타바이트 규모의 데이터<br />
- Velocity: 실시간 스트리밍 데이터<br />
- Variety: 텍스트, 이미지, 비디오, 센서 데이터</p>

<p>이 빅데이터는 딥러닝이 그 잠재력을 발휘할 수 있는 토양이 되었습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://cdn.prod.website-files.com/64b3ee21cac9398c75e5d3ac/66e991eb6a13dfc6f9053fda_660424f01bd5128a9fd71fa8_mlpipeline-new.webp" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">19 / 28</div>
                <div class="page-label">Slide 19</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 20 -->
        <div class="slide-card" id="slide-20">
            <h3 id="20-imagenet-ai-발전의-촉매제">20. ImageNet: AI 발전의 촉매제</h3>

<p><strong>대규모 데이터셋과 경쟁의 생태계</strong></p>

<p>2009년 시작된 ImageNet 프로젝트는 AI 연구 방식을 근본적으로 바꿨습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://miro.medium.com/v2/resize:fit:1009/0*S4LF1ObkVh2ke-I-.jpeg" alt="이미지" loading="lazy" />
</div> <strong>ImageNet의 규모:</strong><br />
- 1,400만 개 이상의 이미지<br />
- 2만 개 이상의 카테고리<br />
- 각 이미지는 수작업으로 레이블링</p>

<p><strong>ILSVRC 대회의 영향:</strong><br />
- 표준화된 벤치마크 제공<br />
- 공정한 모델 비교 가능<br />
- 연구 커뮤니티의 건전한 경쟁<br />
- 매년 획기적인 성능 향상</p>

<p>ImageNet은 "더 많은 데이터와 더 큰 모델"이 더 나은 성능으로 이어진다는 것을 실증적으로 보여줬습니다.</p>

            
            <div class="page-info">
                <div class="page-number">20 / 28</div>
                <div class="page-label">Slide 20</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 21 -->
        <div class="slide-card" id="slide-21">
            <h3 id="21-gpu-컴퓨팅-딥러닝의-하드웨어-혁명">21. GPU 컴퓨팅: 딥러닝의 하드웨어 혁명</h3>

<p><strong>병렬 처리가 가져온 가능성</strong></p>

<p>그래픽 처리를 위해 설계된 GPU가 딥러닝의 핵심 하드웨어가 되었습니다.</p>

<p><strong>GPU가 딥러닝에 적합한 이유:</strong><br />
- 수천 개의 코어로 대규모 병렬 처리<br />
- 행렬 연산에 최적화된 구조<br />
- CPU 대비 10-100배 빠른 학습 속도</p>

<p><strong>CUDA와 cuDNN:</strong><br />
- NVIDIA의 병렬 컴퓨팅 플랫폼<br />
- 딥러닝 연산 최적화 라이브러리<br />
- 연구자들이 쉽게 GPU를 활용 가능</p>

<p>GPU의 도입으로 몇 주 걸리던 학습이 며칠로, 며칠 걸리던 것이 몇 시간으로 단축되었습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://cdn.aitimes.com/news/photo/202403/158294_170234_5721.jpg" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">21 / 28</div>
                <div class="page-label">Slide 21</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 22 -->
        <div class="slide-card" id="slide-22">
            <h3 id="22-alexnet의-충격-2012">22. AlexNet의 충격 (2012)</h3>

<p><strong>딥러닝 시대의 공식적인 시작</strong></p>

<p>2012년 ImageNet 대회에서 AlexNet이 보여준 성능은 AI 역사의 전환점이 되었습니다.</p>

<p><strong>AlexNet의 혁신:</strong><br />
- 8층의 깊은 CNN 구조<br />
- GPU를 활용한 대규모 학습<br />
- ReLU 활성화 함수 사용<br />
- Dropout으로 과적합 방지</p>

<p><strong>압도적인 성능:</strong><br />
- Top-5 오류율 15.3% (2위는 26.2%)<br />
- 이전 최고 기록 대비 10% 이상 개선<br />
- 딥러닝의 우월성을 명확히 입증</p>

<p>이 순간부터 딥러닝은 컴퓨터 비전뿐만 아니라 AI 전반의 주류 기술이 되었습니다.</p>

<p>
<div class="image-container-big">
    <img src="https://www.edge-ai-vision.com/wp-content/uploads/2018/07/LSVRC-winners-over-time-1024x532.png" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">22 / 28</div>
                <div class="page-label">Slide 22</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 23 -->
        <div class="slide-card" id="slide-23">
            <h3 id="23-구글의-고양이-비지도-학습의-가능성">23. 구글의 고양이: 비지도 학습의 가능성</h3>

<p><strong>레이블 없이 개념을 발견하는 AI</strong></p>

<p>2012년, 구글 브레인 팀은 1만 6천 개의 CPU 코어를 사용해 유튜브 영상에서 고양이를 스스로 인식하는 AI를 개발했습니다.</p>

<p><strong>실험의 의미:</strong><br />
- 1천만 개의 유튜브 썸네일 학습<br />
- 레이블 없이 자동으로 특징 추출<br />
- "고양이 뉴런"의 자발적 형성</p>

<p><strong>핵심 통찰:</strong><br />
- AI가 스스로 개념을 형성할 수 있음<br />
- 대규모 비지도 학습의 잠재력<br />
- 인간의 개입 없는 지식 발견</p>

<p>이는 AI가 단순한 패턴 매칭을 넘어 추상적 개념을 학습할 수 있다는 가능성을 보여줬습니다.</p>

<p><a href="https://media.licdn.com/dms/image/v2/C4E12AQHGk_z3TAo4oA/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1556283088500?e=2147483647&amp;v=beta&amp;t=Ut7xfKoZLJXyz7wE8L_JBsaRd-D77-TFqCV3mB04HSs">https://media.licdn.com/dms/image/v2/C4E12AQHGk_z3TAo4oA/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1556283088500?e=2147483647&amp;v=beta&amp;t=Ut7xfKoZLJXyz7wE8L_JBsaRd-D77-TFqCV3mB04HSs</a></p>

            
            <div class="page-info">
                <div class="page-number">23 / 28</div>
                <div class="page-label">Slide 23</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 24 -->
        <div class="slide-card" id="slide-24">
            <h3 id="24-더-깊게-더-크게-신경망-구조의-진화">24. 더 깊게, 더 크게: 신경망 구조의 진화</h3>

<p><strong>깊이와 크기의 경쟁</strong></p>

<p>AlexNet 이후 신경망은 계속해서 깊어지고 커졌습니다.</p>

<p><strong>주요 발전:</strong><br />
- VGGNet (2014): 19층, 균일한 3x3 컨볼루션<br />
- GoogLeNet (2014): 22층, Inception 모듈<br />
- ResNet (2015): 152층, Skip Connection으로 깊이 혁명</p>

<p><a href="https://media.geeksforgeeks.org/wp-content/uploads/20200424011138/ResNet.PNG">https://media.geeksforgeeks.org/wp-content/uploads/20200424011138/ResNet.PNG</a> <strong>깊이의 효과:</strong><br />
- 더 복잡한 특징 학습 가능<br />
- 계층적 표현 학습<br />
- 성능의 지속적 향상</p>

<p>하지만 단순히 크기만 늘리는 것이 능사는 아니었습니다. 효율적인 구조와 학습 방법이 함께 발전해야 했습니다.</p>

            
            <div class="page-info">
                <div class="page-number">24 / 28</div>
                <div class="page-label">Slide 24</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 25 -->
        <div class="slide-card" id="slide-25">
            <h3 id="25-transfer-learning-지식의-재활용">25. Transfer Learning: 지식의 재활용</h3>

<p><strong>한 번 배운 것을 다른 곳에 활용</strong></p>

<p>전이학습(Transfer Learning)은 딥러닝을 실용적으로 만든 핵심 기술입니다.</p>

<p><strong>개념:</strong><br />
- ImageNet으로 사전학습된 모델 활용<br />
- 새로운 작업에 맞게 미세조정(Fine-tuning)<br />
- 적은 데이터로도 높은 성능 달성</p>

<p><strong>장점:</strong><br />
- 학습 시간과 비용 대폭 절감<br />
- 작은 데이터셋에서도 효과적<br />
- 일반적 특징을 특수한 문제에 적용</p>

<p>전이학습은 "바퀴를 다시 발명하지 말라"는 원칙을 AI에 적용한 것입니다.</p>

<p></p>

<div class="image-container">
    <img src="https://framerusercontent.com/images/n6FZeNKpxNGHvLDBnWU1aHvs.jpeg" alt="이미지" loading="lazy" />
</div>

            
            <div class="page-info">
                <div class="page-number">25 / 28</div>
                <div class="page-label">Slide 25</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 26 -->
        <div class="slide-card" id="slide-26">
            <h3 id="26-일상-속-ai의-침투-2010년대">26. 일상 속 AI의 침투 (2010년대)</h3>

<p><strong>우리가 인식하지 못하는 AI의 확산</strong></p>

<p>2010년대 중반, AI는 이미 우리 일상 곳곳에 스며들어 있었습니다.</p>

<p></p>

<div class="image-container">
    <img src="https://miro.medium.com/v2/resize:fit:1400/1*Fm58r_RQ53sEHfwFa28LpA.png" alt="이미지" loading="lazy" />
</div>

<p><strong>숨은 AI 응용들:</strong><br />
- 이메일 스팸 필터: 머신러닝 기반 분류<br />
- 구글 포토 얼굴 인식: 자동 앨범 구성<br />
- 신용카드 사기 탐지: 이상 패턴 감지<br />
- 추천 시스템: 넷플릭스, 유튜브, 아마존<br />
- 음성 인식: Siri, Google Assistant<br />
- 번역 서비스: 신경망 기계 번역</p>

<p><strong>특징:</strong><br />
- 사용자는 AI 존재를 의식하지 못함<br />
- 자연스럽게 서비스에 통합<br />
- 지속적인 성능 개선</p>

<p>AI는 더 이상 미래 기술이 아닌 현재의 일상이 되었습니다.</p>

            
            <div class="page-info">
                <div class="page-number">26 / 28</div>
                <div class="page-label">Slide 26</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 27 -->
        <div class="slide-card" id="slide-27">
            <h3 id="27-컴퓨터-비전의-실용화">27. 컴퓨터 비전의 실용화</h3>

<p><strong>이미지 인식이 가져온 변화</strong></p>

<p>딥러닝은 컴퓨터 비전을 실험실에서 현실로 끌어냈습니다.</p>

<p><strong>주요 응용 분야:</strong><br />
- 의료 영상 진단: 암 조기 발견<br />
- 자율주행: 도로 상황 인식<br />
- 보안: 얼굴 인식 출입 통제<br />
- 농업: 드론을 이용한 작물 상태 분석<br />
- 제조업: 품질 검사 자동화</p>

<p><strong>기술적 발전:</strong><br />
- 객체 검출: YOLO, R-CNN<br />
- 이미지 분할: U-Net, Mask R-CNN<br />
- 3D 비전: 깊이 추정, 3D 재구성</p>

<p>컴퓨터 비전은 AI가 "볼 수 있는 눈"을 갖게 된 것을 의미합니다.</p>

<p>
<div class="image-container-big">
    <img src="https://i.namu.wiki/i/S2KucUG2ySKd3RNGcq-Dyzj5E7-PIBH0MQb4XtjWc0YKyvqyOLx9MP9Tg7CcknD3C2cu0Q4u2XFWESRVwYAYvw.jpg" alt="이미지" loading="lazy" />
</div> </p>

            
            <div class="page-info">
                <div class="page-number">27 / 28</div>
                <div class="page-label">Slide 27</div>
            </div>
            
        </div>
        
        <div class="divider"></div>

        <!-- Slide 28 -->
        <div class="slide-card" id="slide-28">
            <h3 id="28-phase-i-총정리-철학에서-실용으로">28. Phase I 총정리: 철학에서 실용으로</h3>

<p><strong>70년 AI 발전의 첫 번째 장</strong></p>

<p>우리는 튜링의 철학적 질문에서 시작하여 일상 속 AI까지의 여정을 살펴봤습니다.</p>

<p><strong>주요 전환점들:</strong><br />
1. 1950년대: 철학적 질문과 이론적 토대<br />
2. 1960-70년대: 초기 성공과 첫 번째 좌절<br />
3. 1980년대: 신경망의 부활과 새로운 가능성<br />
4. 1990-2000년대: 실용적 기계학습의 발전<br />
5. 2010년대: 빅데이터와 GPU가 만든 딥러닝 혁명</p>

<p><strong>핵심 통찰:</strong><br />
- AI는 실패와 부활을 반복하며 발전<br />
- 이론, 데이터, 하드웨어의 융합이 혁신 창출<br />
- 생물학적 영감이 기술적 돌파구 제공<br />
- 실용성이 연구의 지속가능성 결정</p>

<p>이제 우리는 자연어처리 혁명과 LLM 시대로 들어갈 준비가 되었습니다. Phase II에서는 AI가 어떻게 인간의 언어를 이해하고, 생성하며, 더 나아가 스스로 행동하는 에이전트가 되었는지 탐구하겠습니다.</p>

            
            <div class="page-info">
                <div class="page-number">28 / 28</div>
                <div class="page-label">Slide 28</div>
            </div>
            
        </div>
        
        <!-- Footer -->
        <footer class="footer">
            <div class="footer-title">AI의 진화: 기계는 생각할 수 있는가?</div>
            <div class="footer-subtitle">위데이터랩 인공지능 트렌드 강연</div>
        </footer>
        </div>
    </div>
    
        <script>
        // 스크롤로 이전/다음 파트 이동
        (function() {
            let hasTriggeredNext = false;
            let hasTriggeredPrev = false;
            let isAtBottom = false;
            let isAtTop = false;
            
            function checkScrollPosition() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollHeight = document.documentElement.scrollHeight;
                const clientHeight = window.innerHeight;
                const scrolledToBottom = Math.ceil(scrollTop + clientHeight) >= scrollHeight - 5;
                const scrolledToTop = scrollTop <= 5;
                
                // 페이지 끝에 도달
                if (scrolledToBottom && !hasTriggeredNext && 'slides_part2_continuous.html' && 'slides_part2_continuous.html' !== 'None') {
                    isAtBottom = true;
                    // 페이지 끝에 도달했을 때 안내 메시지 표시
                    if (!document.getElementById('scrollHintBottom')) {
                        const hint = document.createElement('div');
                        hint.id = 'scrollHintBottom';
                        hint.style.cssText = 'position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 100, 255, 0.9); color: white; padding: 16px 32px; border-radius: 50px; font-weight: 600; z-index: 1000; transition: opacity 0.3s ease;';
                        hint.textContent = '계속 스크롤하여 다음 파트로 이동';
                        document.body.appendChild(hint);
                        
                        setTimeout(() => {
                            hint.style.opacity = '0';
                            setTimeout(() => hint.remove(), 300);
                        }, 3000);
                    }
                } else if (!scrolledToBottom) {
                    isAtBottom = false;
                    hasTriggeredNext = false;
                }
                
                // 페이지 맨 위에 도달
                if (scrolledToTop && !hasTriggeredPrev && 'None' && 'None' !== 'None') {
                    isAtTop = true;
                    // 페이지 맨 위에 도달했을 때 안내 메시지 표시
                    if (!document.getElementById('scrollHintTop')) {
                        const hint = document.createElement('div');
                        hint.id = 'scrollHintTop';
                        hint.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(108, 117, 125, 0.9); color: white; padding: 16px 32px; border-radius: 50px; font-weight: 600; z-index: 1000; transition: opacity 0.3s ease;';
                        hint.textContent = '계속 스크롤하여 이전 파트로 이동';
                        document.body.appendChild(hint);
                        
                        setTimeout(() => {
                            hint.style.opacity = '0';
                            setTimeout(() => hint.remove(), 300);
                        }, 3000);
                    }
                } else if (!scrolledToTop) {
                    isAtTop = false;
                    hasTriggeredPrev = false;
                }
            }
            
            // 휠 이벤트로 페이지 끝/시작에서 추가 스크롤 감지
            window.addEventListener('wheel', function(e) {
                // 아래로 스크롤 - 다음 파트로 이동
                if (isAtBottom && e.deltaY > 0 && !hasTriggeredNext && 'slides_part2_continuous.html' && 'slides_part2_continuous.html' !== 'None') {
                    hasTriggeredNext = true;
                    setTimeout(() => {
                        window.location.href = 'slides_part2_continuous.html';
                    }, 300);
                }
                
                // 위로 스크롤 - 이전 파트로 이동
                if (isAtTop && e.deltaY < 0 && !hasTriggeredPrev && 'None' && 'None' !== 'None') {
                    hasTriggeredPrev = true;
                    setTimeout(() => {
                        // 이전 페이지의 맨 아래로 이동
                        window.location.href = 'None#scroll-to-bottom';
                    }, 300);
                }
            });
            
            // 모바일 터치 이벤트 지원
            let touchStartY = 0;
            let touchEndY = 0;
            let touchStartTime = 0;
            let isScrolling = false;
            
            window.addEventListener('touchstart', function(e) {
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isScrolling = false;
            }, { passive: true });
            
            window.addEventListener('touchmove', function(e) {
                isScrolling = true;
            }, { passive: true });
            
            window.addEventListener('touchend', function(e) {
                if (!isScrolling) return;
                
                touchEndY = e.changedTouches[0].clientY;
                const touchDuration = Date.now() - touchStartTime;
                const touchDistance = Math.abs(touchEndY - touchStartY);
                const touchVelocity = touchDistance / touchDuration;
                
                // 빠른 스와이프 감지 (최소 50px 이동, 최대 500ms 시간, 최소 0.1 속도)
                if (touchDistance > 50 && touchDuration < 500 && touchVelocity > 0.1) {
                    const swipeDirection = touchStartY > touchEndY ? 'down' : 'up';
                    
                    // 아래로 스와이프 - 다음 파트로 이동
                    if (swipeDirection === 'down' && isAtBottom && !hasTriggeredNext && 'slides_part2_continuous.html' && 'slides_part2_continuous.html' !== 'None') {
                        hasTriggeredNext = true;
                        setTimeout(() => {
                            window.location.href = 'slides_part2_continuous.html';
                        }, 300);
                    }
                    
                    // 위로 스와이프 - 이전 파트로 이동
                    if (swipeDirection === 'up' && isAtTop && !hasTriggeredPrev && 'None' && 'None' !== 'None') {
                        hasTriggeredPrev = true;
                        setTimeout(() => {
                            window.location.href = 'None#scroll-to-bottom';
                        }, 300);
                    }
                }
            }, { passive: true });
            
            window.addEventListener('scroll', checkScrollPosition);
            
            // URL에 #scroll-to-bottom이 있으면 페이지 맨 아래로 스크롤
            if (window.location.hash === '#scroll-to-bottom') {
                setTimeout(() => {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                    // 해시 제거
                    history.replaceState(null, null, window.location.pathname);
                }, 100);
            }
            
            // 초기 체크
            checkScrollPosition();
        })();
        </script>
        

    <script>
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function scrollToBottom() {
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
        
        // 스크롤 진행률 표시
        window.addEventListener('scroll', function() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / scrollHeight) * 100;
            document.getElementById('progressBar').style.width = scrollPercent + '%';
        });
        
        // Intersection Observer for slide animations
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate-slide-in');
                }
            });
        }, observerOptions);
        
        // Observe all slides
        document.addEventListener('DOMContentLoaded', function() {
            const slides = document.querySelectorAll('.slide-card, .lead-slide');
            slides.forEach(slide => {
                observer.observe(slide);
            });
            
            // Initialize scroll spy
            initScrollSpy();
        });
        
        // Scroll spy functionality
        function initScrollSpy() {
            const slides = document.querySelectorAll('[id^="slide-"]');
            const scrollSpyList = document.getElementById('scrollSpyList');
            const scrollSpy = document.getElementById('scrollSpy');
            
            function calculateDynamicSizes() {
                const containerHeight = window.innerHeight;
                const slideCount = slides.length;
                const padding = 66; // top (33px) and bottom (33px) padding to match nav buttons
                const availableHeight = containerHeight - padding;
                
                // Calculate optimal item height (minimum 16px, maximum 30px)
                let itemHeight = Math.max(Math.min(availableHeight / slideCount, 30), 16);
                
                // Calculate font size based on item height
                let fontSize = Math.max(Math.min(itemHeight * 0.6, 12), 8);
                
                // Calculate line height
                let lineHeight = itemHeight * 0.8;
                
                // If items still don't fit, reduce further
                const totalRequiredHeight = itemHeight * slideCount;
                if (totalRequiredHeight > availableHeight) {
                    const scaleFactor = availableHeight / totalRequiredHeight;
                    itemHeight *= scaleFactor;
                    fontSize *= scaleFactor;
                    lineHeight *= scaleFactor;
                }
                
                return {
                    itemHeight: Math.max(itemHeight, 12), // absolute minimum
                    fontSize: Math.max(fontSize, 7), // absolute minimum
                    lineHeight: Math.max(lineHeight, 10) // absolute minimum
                };
            }
            
            function updateScrollSpySizes() {
                const sizes = calculateDynamicSizes();
                document.querySelectorAll('.scroll-spy-item').forEach((item, index) => {
                    item.style.height = sizes.itemHeight + 'px';
                    item.style.fontSize = sizes.fontSize + 'px';
                    item.style.lineHeight = sizes.lineHeight + 'px';
                    
                    // Update title text for screen size
                    const slide = slides[index];
                    if (slide) {
                        const slideTitle = getSlideTitle(slide);
                        const span = item.querySelector('span');
                        if (span) {
                            span.textContent = slideTitle;
                        }
                    }
                });
            }
            
            // Generate scroll spy items
            const initialSizes = calculateDynamicSizes();
            slides.forEach((slide, index) => {
                const slideNumber = slide.id.replace('slide-', '');
                const slideTitle = getSlideTitle(slide);
                
                const spyItem = document.createElement('div');
                spyItem.className = 'scroll-spy-item';
                spyItem.setAttribute('data-slide', slide.id);
                spyItem.style.height = initialSizes.itemHeight + 'px';
                spyItem.style.fontSize = initialSizes.fontSize + 'px';
                spyItem.style.lineHeight = initialSizes.lineHeight + 'px';
                spyItem.style.display = 'flex';
                spyItem.style.alignItems = 'center';
                spyItem.innerHTML = `
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${slideTitle}</span>
                `;
                
                spyItem.addEventListener('click', () => {
                    document.getElementById(slide.id).scrollIntoView({ behavior: 'smooth' });
                });
                
                scrollSpyList.appendChild(spyItem);
            });
            
            // Update active item on scroll
            const spyObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Update active spy item
                        document.querySelectorAll('.scroll-spy-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        const activeItem = document.querySelector(`[data-slide="${entry.target.id}"]`);
                        if (activeItem) {
                            activeItem.classList.add('active');
                        }
                    }
                });
            }, {
                rootMargin: '-40% 0px -40% 0px',
                threshold: 0
            });
            
            slides.forEach(slide => {
                spyObserver.observe(slide);
            });
            
            // Handle window resize with debouncing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateScrollSpySizes();
                }, 100);
            });
        }
        
        function getSlideTitle(slide) {
            // Calculate max title length based on screen size
            const screenWidth = window.innerWidth;
            let maxLength = 35;
            
            if (screenWidth < 1200) maxLength = 25;
            if (screenWidth < 1000) maxLength = 20;
            if (screenWidth < 800) maxLength = 15;
            
            // Try to get the first heading or first few words of content
            const heading = slide.querySelector('h1, h2, h3');
            if (heading) {
                const text = heading.textContent.trim();
                return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
            }
            
            // If no heading, get first paragraph
            const firstPara = slide.querySelector('p');
            if (firstPara) {
                const text = firstPara.textContent.trim();
                return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
            }
            
            return 'Slide';
        }
        
    </script>
</body>
</html>